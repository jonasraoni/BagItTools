<html>
    <head>
        <script
            type="text/javascript"
            src="../js/jquery-1.4.2.min.js">
        </script>
        <script
            type="text/javascript"
            src="../syntax_highlighter/scripts/shCore.js">
        </script>
        <script
            type="text/javascript"
            src="../syntax_highlighter/scripts/shBrushJScript.js">
        </script>
        <script
            type="text/javascript"
            src="../syntax_highlighter/scripts/shBrushPhp.js">
        </script>
        <script
            type="text/javascript"
            src="../syntax_highlighter/scripts/shBrushXml.js">
        </script>
        <link
            href="../syntax_highlighter/styles/shCore.css" rel="stylesheet"
            type="text/css"
        />
        <link
            href="../syntax_highlighter/styles/shCoreEclipse.css"
            rel="stylesheet" type="text/css"
        />
        <link
            href="../syntax_highlighter/styles/shThemeWordpress.css"
            rel="stylesheet" type="text/css"
        />
    </head>
    <body>
        <pre class="brush: php">&lt;?php

namespace whikloj\BagItTools;

/**
 * Utility class to hold static functions.
 *
 * @package whikloj\BagItTools
 * @author whikloj
 * @since 1.0.0
 */
class BagUtils
{

    /**
     * Valid character set MIME names from IANA.
     */
    const CHARACTER_SETS = [
        &quot;utf-8&quot; =&gt; &quot;UTF-8&quot;,
        &quot;utf-16&quot; =&gt; &quot;UTF-16&quot;,
        &quot;us-ascii&quot; =&gt; &quot;US-ASCII&quot;,
        &quot;iso-8859-1&quot; =&gt; &quot;ISO-8859-1&quot;,
        &quot;iso-8859-2&quot; =&gt; &quot;ISO-8859-2&quot;,
        &quot;iso-8859-3&quot; =&gt; &quot;ISO-8859-3&quot;,
        &quot;iso-8859-4&quot; =&gt; &quot;ISO-8859-4&quot;,
        &quot;iso-8859-5&quot; =&gt; &quot;ISO-8859-5&quot;,
        &quot;iso-8859-6&quot; =&gt; &quot;ISO-8859-6&quot;,
        &quot;iso-8859-7&quot; =&gt; &quot;ISO-8859-7&quot;,
        &quot;iso-8859-8&quot; =&gt; &quot;ISO-8859-8&quot;,
        &quot;iso-8859-9&quot; =&gt; &quot;ISO-8859-9&quot;,
        &quot;iso-8859-10&quot; =&gt; &quot;ISO-8859-10&quot;,
        &quot;shift_jis&quot; =&gt; &quot;Shift_JIS&quot;,
        &quot;euc-jp&quot; =&gt; &quot;EUC-JP&quot;,
        &quot;iso-2022-kr&quot; =&gt; &quot;ISO-2022-KR&quot;,
        &quot;euc-kr&quot; =&gt; &quot;EUC-KR&quot;,
        &quot;iso-2022-jp&quot; =&gt; &quot;ISO-2022-JP&quot;,
        &quot;iso-2022-jp-2&quot; =&gt; &quot;ISO-2022-JP-2&quot;,
        &quot;iso-8859-6-e&quot; =&gt; &quot;ISO-8859-6-E&quot;,
        &quot;iso-8859-6-i&quot; =&gt; &quot;ISO-8859-6-I&quot;,
        &quot;iso-8859-8-e&quot; =&gt; &quot;ISO-8859-8-E&quot;,
        &quot;iso-8859-8-i&quot; =&gt; &quot;ISO-8859-8-I&quot;,
        &quot;gb2312&quot; =&gt; &quot;GB2312&quot;,
        &quot;big5&quot; =&gt; &quot;Big5&quot;,
        &quot;koi8-r&quot; =&gt; &quot;KOI8-R&quot;,
    ];

    /**
     * BagUtils constructor.
     */
    private function __construct()
    {
        // This constructor left intentionally blank.
    }

    /**
     * Utility to test a filename as . or ..
     *
     * @param string $filename
     *    Basename of a file or directory.
     * @return bool
     *    True if it is a dot directory name.
     */
    public static function isDotDir($filename)
    {
        return ($filename == &quot;.&quot; || $filename == &quot;..&quot;);
    }

    /**
     * Rebase the path in the data directory as payloads only deal in there.
     *
     * @param string $path
     *   The provided path.
     * @return string
     *   The (possibly) rebased path.
     */
    public static function baseInData($path)
    {
        if (substr($path, 0, 5) !== 'data/') {
            $path = &quot;data/&quot; . ltrim($path, &quot;/&quot;);
        }
        return $path;
    }

    /**
     * Return all files that match the pattern, or an empty array.
     *
     * @param string $pattern
     *   The pattern to search for.
     *
     * @return array
     *   Array of matches.
     *
     * @throws \whikloj\BagItTools\BagItException
     *   Error in matching pattern.
     */
    public static function findAllByPattern($pattern)
    {
        $matches=glob($pattern);
        if ($matches === false) {
            throw new BagItException(&quot;Error matching pattern {$pattern}&quot;);
        }
        return $matches;
    }

    /**
     * Check the provided lower case name of a character set against our list. If we have it, return the proper MIME
     * name.
     * @param string $charset
     *   The trimmed lowercase version of the character set MIME name.
     * @return string|null
     *   The proper name or null if we don't have it.
     */
    public static function getValidCharset($charset)
    {
        if (in_array($charset, array_keys(self::CHARACTER_SETS))) {
            return self::CHARACTER_SETS[$charset];
        }
        return null;
    }

    /**
     * There is a method that deal with Sven Arduwie proposal https://www.php.net/manual/en/function.realpath.php#84012
     * And runeimp at gmail dot com proposal https://www.php.net/manual/en/function.realpath.php#112367
     * @author  moreau.marc.web@gmail.com
     * @param string $path
     * @return string
     */
    public static function getAbsolute($path)
    {
        // Cleaning path regarding OS
        $path = mb_ereg_replace('\\\\|/', DIRECTORY_SEPARATOR, $path, 'msr');
        // Check if path start with a separator (UNIX)
        $startWithSeparator = $path[0] === DIRECTORY_SEPARATOR;
        // Check if start with drive letter
        preg_match('/^[a-z]:/', $path, $matches);
        $startWithLetterDir = isset($matches[0]) ? $matches[0] : false;
        // Get and filter empty sub paths
        $subPaths = array_filter(explode(DIRECTORY_SEPARATOR, $path), 'mb_strlen');

        $absolutes = [];
        foreach ($subPaths as $subPath) {
            if ('.' === $subPath) {
                continue;
            }
            // if $startWithSeparator is false
            // and $startWithLetterDir
            // and (absolutes is empty or all previous values are ..)
            // save absolute cause that's a relative and we can't deal with that and just forget that we want go up
            if ('..' === $subPath
                &amp;&amp; !$startWithSeparator
                &amp;&amp; !$startWithLetterDir
                &amp;&amp; empty(array_filter($absolutes, function ($value) {
                    return !('..' === $value);
                }))
            ) {
                $absolutes[] = $subPath;
                continue;
            }
            if ('..' === $subPath) {
                array_pop($absolutes);
                continue;
            }
            $absolutes[] = $subPath;
        }

        return
            (($startWithSeparator ? DIRECTORY_SEPARATOR : $startWithLetterDir) ?
                $startWithLetterDir . DIRECTORY_SEPARATOR : ''
            ) . implode(DIRECTORY_SEPARATOR, $absolutes);
    }

    /**
     * Paths for new and existing files should not have these conditions.
     *
     * @param string $path
     *   The relative path from an existing bag file or as a destination for a new file.
     * @return bool
     *   True if invalid characters/character sequences exist.
     */
    public static function invalidPathCharacters($path)
    {
        $path = urldecode($path);
        return ($path[0] === DIRECTORY_SEPARATOR || strpos($path, &quot;~&quot;) !== false ||
            substr($path, 0, 3) == &quot;../&quot;);
    }

    /**
     * Recursively list all files in a directory, except dot files.
     *
     * @param string $directory
     *   The starting full path.
     * @param array $exclusions
     *   Array with directory names to skip.
     * @return array
     *   List of files with absolute path.
     */
    public static function getAllFiles($directory, $exclusions = [])
    {
        $paths = [$directory];
        $found_files = [];

        while (count($paths) &gt; 0) {
            $currentPath = array_shift($paths);
            $files = scandir($currentPath);
            foreach ($files as $file) {
                if (self::isDotDir($file)) {
                    continue;
                }
                $fullPath = $currentPath . DIRECTORY_SEPARATOR . $file;
                if (is_dir($fullPath) &amp;&amp; !in_array($file, $exclusions)) {
                    $paths[] = $fullPath;
                } elseif (is_file($fullPath)) {
                    $found_files[] = $fullPath;
                }
            }
        }
        return $found_files;
    }
}
</pre>
        <script type="text/javascript">
             SyntaxHighlighter.all();
             jQuery('.gutter div').each(function(key, data){
                jQuery(data).prepend('<a name="L'+jQuery(data).text()+'"/>');
             });
        </script>
    </body>
</html>
<html>
    <head>
        <script
            type="text/javascript"
            src="../js/jquery-1.4.2.min.js">
        </script>
        <script
            type="text/javascript"
            src="../syntax_highlighter/scripts/shCore.js">
        </script>
        <script
            type="text/javascript"
            src="../syntax_highlighter/scripts/shBrushJScript.js">
        </script>
        <script
            type="text/javascript"
            src="../syntax_highlighter/scripts/shBrushPhp.js">
        </script>
        <script
            type="text/javascript"
            src="../syntax_highlighter/scripts/shBrushXml.js">
        </script>
        <link
            href="../syntax_highlighter/styles/shCore.css" rel="stylesheet"
            type="text/css"
        />
        <link
            href="../syntax_highlighter/styles/shCoreEclipse.css"
            rel="stylesheet" type="text/css"
        />
        <link
            href="../syntax_highlighter/styles/shThemeWordpress.css"
            rel="stylesheet" type="text/css"
        />
    </head>
    <body>
        <pre class="brush: php">&lt;?php

namespace whikloj\BagItTools;

/**
 * Class for holding and interacting with fetch.txt data.
 *
 * @package whikloj\BagItTools
 * @author whikloj
 * @since 1.0.0
 */
class Fetch
{

    /**
     * The fetch filename.
     */
    const FILENAME = &quot;fetch.txt&quot;;

    /**
     * The bag this fetch file is part of
     *
     * @var \whikloj\BagItTools\Bag
     */
    private $bag;

    /**
     * The current absolute path to the fetch.txt file.
     *
     * @var string
     */
    private $filename;

    /**
     * Information from the fetch.txt, array of arrays with keys 'uri', 'size', and 'destination'
     *
     * @var array
     */
    private $files;

    /**
     * Errors
     *
     * @var array
     */
    private $fetchErrors = [];

    /**
     * Urls and Files that validated and should be downloaded.
     *
     * @var array
     */
    private $downloadQueue = [];

    /**
     * Curl version number string.
     *
     * @var string
     */
    private $curlVersion;

    /**
     * Standard curl options to use.
     *
     * @var array
     */
    private $curlOptions = [
        CURLOPT_CONNECTTIMEOUT =&gt; 10,
        CURLOPT_RETURNTRANSFER =&gt; true,
    ];

    /**
     * Fetch constructor.
     *
     * @param \whikloj\BagItTools\Bag $bag
     *   The bag this fetch is part of.
     * @param bool $load
     *   Whether to load a fetch.txt
     */
    public function __construct(Bag $bag, $load = false)
    {
        $this-&gt;bag = $bag;
        $this-&gt;files = [];
        $this-&gt;curlVersion = curl_version()['version_number'];
        $this-&gt;filename = $this-&gt;bag-&gt;makeAbsolute(self::FILENAME);
        $this-&gt;setupCurl();
        if ($load) {
            $this-&gt;loadFiles();
        }
    }

    /**
     * Return the array of file data.
     *
     * @return array
     */
    public function getData()
    {
        return $this-&gt;files;
    }

    /**
     * Download the files.
     *
     * @throws \whikloj\BagItTools\BagItException
     *   Unable to open file handle to save to.
     */
    public function downloadAll()
    {
        $this-&gt;resetErrors();
        $this-&gt;downloadQueue = [];
        foreach ($this-&gt;files as $file) {
            try {
                $this-&gt;validateData($file);
            } catch (BagItException $e) {
                $this-&gt;addError($e-&gt;getMessage());
                continue;
            }
            $this-&gt;downloadQueue[] = $file;
        }
        $this-&gt;downloadFiles();
    }

    /**
     * Validate fetch data.
     *
     * @param array $fetchData
     *   Array with mandatory keys 'uri' and 'destination' and optional key 'size'.
     *
     * @throws \whikloj\BagItTools\BagItException
     *   For all validation errors.
     */
    private function validateData(array $fetchData)
    {
        $uri = $fetchData['uri'];
        $dest = BagUtils::baseInData($fetchData['destination']);
        if (!$this-&gt;validateUrl($uri)) {
            // skip invalid URLs or non-http URLs
            throw new BagItException(&quot;URL {$uri} does not seem to have a scheme or host&quot;);
        }
        if (!$this-&gt;internalValidateUrl($uri)) {
            throw new BagItException(&quot;This library only supports http/https URLs&quot;);
        }
        if (!$this-&gt;validatePath($dest)) {
            // Skip destinations with %xx other than %0A, %0D and %25
            throw new BagItException(&quot;Destination paths can't have any percent encoded characters except CR, LF, &amp; %&quot;);
        }
        if (!$this-&gt;bag-&gt;pathInBagData($dest)) {
            throw new BagItException(&quot;Path {$dest} resolves outside the bag.&quot;);
        }
    }

    /**
     * Download a single file as it is added to the fetch file so we can generate checksums.
     *
     * @param array $fetchData
     *   Array of data with keys 'uri', 'destination' and optionally 'size'.
     *
     * @throws \whikloj\BagItTools\BagItException
     */
    public function download($fetchData)
    {
        $this-&gt;validateData($fetchData);
        $uri = $fetchData['uri'];
        if ($this-&gt;urlExistsInFile($uri)) {
            throw new BagItException(&quot;This URL ({$uri}) is already in fetch.txt&quot;);
        }
        $dest = BagUtils::baseInData($fetchData['destination']);
        if ($this-&gt;destinationExistsInFile($dest)) {
            throw new BagItException(&quot;This destination ({$dest}) is already in the fetch.txt&quot;);
        }
        $fullDest = $this-&gt;bag-&gt;makeAbsolute($dest);
        $fullDest = \Normalizer::normalize($fullDest);
        if (file_exists($fullDest)) {
            throw new BagItException(&quot;File already exists at the destination path {$dest}&quot;);
        }
        $ch = $this-&gt;createCurl($uri, true);
        $output = curl_exec($ch);
        $error = curl_error($ch);
        curl_close($ch);
        if (!empty($error)) {
            throw new BagItException(&quot;Error with download of {$uri} : {$error}&quot;);
        }
        $this-&gt;saveFileData($output, $dest);
        $this-&gt;files[] = [
            'uri' =&gt; $fetchData['uri'],
            'size' =&gt; (!empty($fetchData['size']) ? $fetchData['size'] : '-'),
            'destination' =&gt; $dest,
        ];
    }

    /**
     * Remove the URL (case-insensitive match) from the fetch file.
     *
     * @param string $url
     *   The url to remove.
     */
    public function removeFile($url)
    {
        if ($this-&gt;urlExistsInFile($url)) {
            $newFiles = [];
            foreach ($this-&gt;files as $file) {
                if (strtolower($url) !== strtolower($file['uri'])) {
                    $newFiles[] = $file;
                } else {
                    $fullFile = $this-&gt;bag-&gt;makeAbsolute($file['destination']);
                    if (file_exists($fullFile)) {
                        unlink($fullFile);
                    }
                }
            }
            $this-&gt;files = $newFiles;
        }
    }

    /**
     * Update the fetch.txt on disk with the fetch file records.
     *
     * @throws \whikloj\BagItTools\BagItException
     *   If we can't write to disk.
     */
    public function update()
    {
        $this-&gt;writeToDisk();
    }

    /**
     * Remove any downloaded files referenced in fetch.txt. This is called before we package up the Bag or finalize the
     * directory.
     */
    public function cleanup()
    {
        foreach ($this-&gt;files as $file) {
            $fullPath = BagUtils::getAbsolute($this-&gt;bag-&gt;makeAbsolute($file['destination']));
            if (file_exists($fullPath)) {
                // Remove the file because we are being packaged or finalized.
                unlink($fullPath);
                $this-&gt;bag-&gt;checkForEmptyDir($fullPath);
            }
        }
    }

    /**
     * Clean up any downloaded files and then wipe the internal data array.
     */
    public function clearData()
    {
        $this-&gt;cleanup();
        $this-&gt;files = [];
        if (file_exists($this-&gt;filename)) {
            unlink($this-&gt;filename);
        }
    }

    /**
     * Return the errors.
     *
     * @return array
     *   Array of errors.
     */
    public function getErrors()
    {
        return $this-&gt;fetchErrors;
    }

    /**
     * Check if the destination is supposed to be used by a fetched url.
     *
     * @param string $dest
     *   The relative path to check.
     * @return bool
     *   True if the destination is in the fetch.txt
     */
    public function reservedPath($dest)
    {
        $dest = BagUtils::baseInData($dest);
        return $this-&gt;destinationExistsInFile($dest);
    }

    /*
     * Private functions
     */

    /**
     * Load an existing fetch.txt
     */
    private function loadFiles()
    {
        $this-&gt;resetErrors();
        if (file_exists($this-&gt;filename)) {
            $fp = fopen($this-&gt;filename, &quot;rb&quot;);
            $lineCount = 0;
            while (!feof($fp)) {
                $lineCount += 1;
                $line = fgets($fp);
                $line = $this-&gt;bag-&gt;decodeText($line);
                $line = trim($line);
                if (empty($line)) {
                    continue;
                }
                if (preg_match(&quot;~^([^\s]+)\s+(\d+|\-)\s+(.*)$~&quot;, $line, $matches)) {
                    // We just store what you give us, we'll validate when you load the contents to validate the bag.
                    $uri = $matches[1];
                    $filesize = $matches[2];
                    $destination = BagUtils::baseInData($matches[3]);
                    $this-&gt;files[] = [
                        'uri' =&gt; $uri,
                        'size' =&gt; $filesize,
                        'destination' =&gt; $destination,
                    ];
                } else {
                    $this-&gt;addError(&quot;Line {$lineCount} : This line is not valid.&quot;);
                }
            }
        }
    }

    /**
     * Write out data collected via curl to disk.
     *
     * @param mixed $content
     *   The content from curl.
     * @param string $destination
     *   The relative path to the final file.
     * @throws \whikloj\BagItTools\BagItException
     *   Trouble writing to disk.
     */
    private function saveFileData($content, $destination)
    {
        if (strlen($content) &gt; 0) {
            $fullDest = $this-&gt;bag-&gt;makeAbsolute($destination);
            $fullDest = \Normalizer::normalize($fullDest);
            $dirname = dirname($fullDest);
            if (substr($this-&gt;bag-&gt;makeRelative($dirname), 0, 5) == &quot;data/&quot;) {
                // Create any missing missing directories inside data.
                if (!file_exists($dirname)) {
                    mkdir($dirname, 0777, true);
                }
            }
            $res = file_put_contents($fullDest, $content, LOCK_EX);
            if ($res === false) {
                throw new BagItException(&quot;Unable to write to file {$fullDest}&quot;);
            }
        }
    }

    /**
     * Initiate a curl handler
     *
     * @param string $url
     *   The URL to download.
     * @param bool $single
     *   If this is a download() call versus a downloadAll() call.
     * @return false|resource
     *   False on error, otherwise a Curl resource.
     */
    private function createCurl($url, $single = false)
    {
        $ch = curl_init($url);
        $options = $this-&gt;curlOptions;
        if ($single === true) {
            // If this is set during curl_multi_exec, it swallows error messages.
            $options[CURLOPT_FAILONERROR] = true;
        }
        curl_setopt_array($ch, $options);
        return $ch;
    }

    /**
     * Download files using Curl.
     *
     * @throws \whikloj\BagItTools\BagItException
     *   Unable to open a file handle to download to.
     */
    private function downloadFiles()
    {
        if (count($this-&gt;downloadQueue) &gt; 0) {
            $mh = curl_multi_init();
            $curl_handles = [];
            $destinations = [];
            if ($mh !== false) {
                if (version_compare($this-&gt;curlVersion, '7.62.0') &lt;= 0) {
                    // Try enabling HTTP/1.1 pipelining and HTTP/2 multiplexing.
                    curl_multi_setopt($mh, CURLMOPT_PIPELINING, CURLPIPE_HTTP1 | CURLPIPE_MULTIPLEX);
                }
                if (version_compare($this-&gt;curlVersion, '7.30.0') &lt;= 0) {
                    curl_multi_setopt($mh, CURLMOPT_MAX_TOTAL_CONNECTIONS, 10);
                }
                foreach ($this-&gt;downloadQueue as $key =&gt; $download) {
                    $fullPath = $this-&gt;bag-&gt;makeAbsolute($download['destination']);
                    // Don't download again.
                    if (!file_exists($fullPath)) {
                        $destinations[$key] = $fullPath;
                        $curl_handles[$key] = $this-&gt;createCurl($download['uri']);
                        curl_multi_add_handle($mh, $curl_handles[$key]);
                    }
                }
                $running = null;
                do {
                    curl_multi_exec($mh, $running);
                } while ($running);
                for ($x = 0; $x &lt; count($curl_handles); $x += 1) {
                    $error = curl_error($curl_handles[$x]);
                    $url = curl_getinfo($curl_handles[$x], CURLINFO_EFFECTIVE_URL);
                    if (!empty($error)) {
                        $this-&gt;addError(&quot;Failed to fetch URL ({$url})&quot;);
                    } else {
                        $content = curl_multi_getcontent($curl_handles[$x]);
                        $this-&gt;saveFileData($content, $destinations[$x]);
                    }
                    curl_multi_remove_handle($mh, $curl_handles[$x]);
                    curl_close($curl_handles[$x]);
                }
                curl_multi_close($mh);
            }
        }
    }

    /**
     * Utility to recreate the fetch file using the currently stored files.
     *
     * @throws \whikloj\BagItTools\BagItException
     *   If we can't write the fetch file.
     */
    private function writeToDisk()
    {
        if (file_exists($this-&gt;filename)) {
            unlink($this-&gt;filename);
        }
        if (count($this-&gt;files) &gt; 0) {
            $fp = fopen($this-&gt;filename, &quot;wb&quot;);
            if ($fp === false) {
                throw new BagItException(&quot;Unable to write {$this-&gt;filename}&quot;);
            }
            foreach ($this-&gt;files as $fileData) {
                $line = &quot;{$fileData['uri']} {$fileData['size']} {$fileData['destination']}&quot; . PHP_EOL;
                $line = $this-&gt;bag-&gt;encodeText($line);
                fwrite($fp, $line);
            }
            fclose($fp);
        }
    }

    /**
     * Validate URLs can be processed by this library.
     *
     * @param string $url
     *   The URL.
     * @return bool
     *   True if we can process it.
     */
    private function validateUrl($url)
    {
        $parts = parse_url($url);
        if (!isset($parts['scheme']) || !isset($parts['host'])) {
            return false;
        }
        return true;
    }

    /**
     * BagItTools specific (non-spec) requirements for URLs.
     *
     * @param string $url
     *   The URL.
     * @return bool
     *   True if we can process it.
     */
    private function internalValidateUrl($url)
    {
        $parts = parse_url($url);
        if ($parts['scheme'] !== 'http' &amp;&amp; $parts['scheme'] !== 'https') {
            return false;
        }
        return true;
    }

    /**
     * Validate the path for fetch files.
     *
     * @param string $dest
     *   The destination file path.
     * @return bool
     *   True if it is valid.
     */
    private function validatePath($dest)
    {
        // You can't have any encoded characters in the destination string except LF, CR, CRLF and % itself.
        if (strpos($dest, '%') !== false) {
            $parts = explode('%', $dest);
            foreach ($parts as $part) {
                $char = substr($part, 0, 2);
                $char = strtolower($char);
                if (!($char == '0a' || $char == '0d' || $char == '25')) {
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * Check if the url is already in the file.
     *
     * @param string $url
     *   The url to check
     * @return bool
     *   True if a duplicate.
     */
    private function urlExistsInFile($url)
    {
        $uris = array_column($this-&gt;files, 'uri');
        array_walk($uris, function (&amp;$item) {
            $item = strtolower($item);
        });
        return (in_array(strtolower($url), $uris));
    }

    /**
     * Check if the destination path is already in the file.
     *
     * @param string $dest
     *   Relative path to the destination file.
     * @return bool
     *   True if a duplicate.
     */
    private function destinationExistsInFile($dest)
    {
        $paths = array_column($this-&gt;files, 'destination');
        array_walk($paths, function (&amp;$item) {
            $item = strtolower($item);
        });
        return (in_array(strtolower($dest), $paths));
    }

    /**
     * Set general CURLOPTS based on the Curl version.
     */
    private function setupCurl()
    {
        if (!defined('CURLMOPT_MAX_TOTAL_CONNECTIONS')) {
            define('CURLMOPT_MAX_TOTAL_CONNECTIONS', 13);
        }
        if (!defined('CURL_PIPEWAIT')) {
            define('CURL_PIPEWAIT', 237);
        }
        if (version_compare('7.0', PHP_VERSION) &gt;= 0 &amp;&amp;
            version_compare($this-&gt;curlVersion, '7.43.0') &gt;= 0) {
            // Add CURL_PIPEWAIT if we can, using the integer to avoid problems in PHP 5.6
            $this-&gt;curlOptions[CURL_PIPEWAIT] = true;
        }
    }

    /**
     * Reset the error and warning logs.
     */
    private function resetErrors()
    {
        $this-&gt;fetchErrors = [];
    }

    /**
     * Add an error for the fetch file.
     *
     * @param string $message
     *   The message.
     */
    private function addError($message)
    {
        $this-&gt;fetchErrors[] = [
            'file' =&gt; self::FILENAME,
            'message' =&gt; $message,
        ];
    }
}
</pre>
        <script type="text/javascript">
             SyntaxHighlighter.all();
             jQuery('.gutter div').each(function(key, data){
                jQuery(data).prepend('<a name="L'+jQuery(data).text()+'"/>');
             });
        </script>
    </body>
</html>
<html>
    <head>
        <script
            type="text/javascript"
            src="../js/jquery-1.4.2.min.js">
        </script>
        <script
            type="text/javascript"
            src="../syntax_highlighter/scripts/shCore.js">
        </script>
        <script
            type="text/javascript"
            src="../syntax_highlighter/scripts/shBrushJScript.js">
        </script>
        <script
            type="text/javascript"
            src="../syntax_highlighter/scripts/shBrushPhp.js">
        </script>
        <script
            type="text/javascript"
            src="../syntax_highlighter/scripts/shBrushXml.js">
        </script>
        <link
            href="../syntax_highlighter/styles/shCore.css" rel="stylesheet"
            type="text/css"
        />
        <link
            href="../syntax_highlighter/styles/shCoreEclipse.css"
            rel="stylesheet" type="text/css"
        />
        <link
            href="../syntax_highlighter/styles/shThemeWordpress.css"
            rel="stylesheet" type="text/css"
        />
    </head>
    <body>
        <pre class="brush: php">&lt;?php

namespace whikloj\BagItTools;

/**
 * Bag class as normal interface for all actions and holder of supporting constructs.
 *
 * @package \whikloj\BagItTools
 * @author whikloj
 * @since 1.0.0
 */
class Bag
{

    /**
     * The default algorithm to use if one is not specified.
     */
    const DEFAULT_HASH_ALGORITHM = 'sha512';

    /**
     * The default file encoding if one is not specified.
     */
    const DEFAULT_FILE_ENCODING = 'UTF-8';

    /**
     * The default bagit version.
     */
    const DEFAULT_BAGIT_VERSION = [
        'major' =&gt; 1,
        'minor' =&gt; 0,
    ];

    /**
     * Bag-info fields that MUST not be repeated.
     */
    const BAG_INFO_MUST_NOT_REPEAT = [
        'payload-oxum',
    ];

    /**
     * Bag-info fields that SHOULD NOT be repeated.
     */
    const BAG_INFO_SHOULD_NOT_REPEAT = [
        'bagging-date',
        'bag-size',
        'bag-group-identifer',
        'bag-count',
    ];

    /**
     * Reserved element names for Bag-info fields.
     */
    const BAG_INFO_RESERVED_ELEMENTS = [
        'source-organization',
        'organization-address',
        'contact-name',
        'contact-phone',
        'contact-email',
        'external-description',
        'bagging-date',
        'external-identifier',
        'payload-oxum',
        'bag-size',
        'bag-group-identifier',
        'bag-count',
        'internal-sender-identifier',
        'internal-sender-description',
    ];

    /**
     * Fields you can't set because we generate them on $bag-&gt;update().
     */
    const BAG_INFO_GENERATED_ELEMENTS = [
        'payload-oxum',
        'bagging-date',
    ];

    /**
     * Array of BagIt approved names of hash algorithms to the PHP names of
     * those hash algorithms for use with hash_file().
     *
     * @see https://tools.ietf.org/html/rfc8493#section-2.4
     *
     * @var array
     */
    const HASH_ALGORITHMS = array(
        'md5' =&gt; 'md5',
        'sha1' =&gt; 'sha1',
        'sha224' =&gt; 'sha224',
        'sha256' =&gt; 'sha256',
        'sha384' =&gt; 'sha384',
        'sha512' =&gt; 'sha512',
        'sha3224' =&gt; 'sha3-224',
        'sha3256' =&gt; 'sha3-256',
        'sha3384' =&gt; 'sha3-384',
        'sha3512' =&gt; 'sha3-512',
    );

    /**
     * File names that are not allowed on windows, should be disallowed in bags for interoperability.
     */
    const WINDOWS_RESERVED_NAMES = [
        'CON', 'PRN', 'AUX', 'NUL', 'COM1', 'COM2', 'COM3', 'COM4', 'COM5', 'COM6', 'COM7', 'COM8', 'COM9', 'LPT1',
        'LPT2', 'LPT3', 'LPT4', 'LPT5', 'LPT6', 'LPT7', 'LPT8', 'LPT9',
    ];

    const WINDOWS_PATH_CHARACTERS = [
        '&lt;', '&gt;', ':', '&quot;', '/', '|', '?', '*',
    ];

    /**
     * Extensions which map to a tar file.
     */
    const TAR_EXTENSIONS = [
        'tar',
        'tgz',
        'tar.gz',
        'tar.bz2',
    ];

    /**
     * Extensions which map to a zip file.
     */
    const ZIP_EXTENSIONS = [
        'zip',
    ];

    /**
     * All the extensions in one array.
     *
     * @var array
     */
    private $packageExtensions;

    /**
     * Array of current bag version with keys 'major' and 'minor'.
     *
     * @var array
     */
    private $currentVersion;

    /**
     * Current bag file encoding.
     *
     * @var string
     */
    private $currentFileEncoding;

    /**
     * Array of payload manifests.
     *
     * @var array
     */
    private $payloadManifests;

    /**
     * Array of tag manifests.
     *
     * @var array
     */
    private $tagManifests;

    /**
     * List of relative file paths for all files.
     *
     * @var array
     */
    private $payloadFiles;

    /**
     * Reference to a Fetch file or null if not used.
     *
     * @var \whikloj\BagItTools\Fetch
     */
    private $fetchFile = null;

    /**
     * The absolute path to the root of the bag, all other file paths are
     * relative to this. This path is stored with / as directory separator
     * regardless of the OS.
     *
     * @var string
     */
    private $bagRoot;

    /**
     * Is this an extended bag?
     *
     * @var boolean
     */
    private $isExtended;

    /**
     * The valid algorithms from the current version of PHP filtered to those
     * supported by the BagIt specification. Stored to avoid extraneous calls
     * to hash_algos().
     *
     * @var array
     */
    private $validHashAlgorithms;

    /**
     * Errors when validating a bag.
     *
     * @var array
     */
    private $bagErrors;

    /**
     * Warnings when validating a bag.
     *
     * @var array
     */
    private $bagWarnings;

    /**
     * Have we changed the bag and not written it to disk?
     *
     * @var boolean
     */
    private $changed = false;

    /**
     * Bag Info data.
     *
     * @var array
     */
    private $bagInfoData = [];

    /**
     * Unique array of all Bag info tags/values. Tags are stored once in lower case with an array of all instances
     * of values. This index does not save order.
     *
     * @var array
     */
    private $bagInfoTagIndex = [];

    /**
     * Did we load this from disk.
     *
     * @var boolean
     */
    private $loaded = false;

    /**
     * Bag constructor.
     *
     * @param string $rootPath
     *   The path of the root of the new or existing bag.
     * @param boolean $new
     *   Are we making a new bag?
     *
     * @throws \whikloj\BagItTools\BagItException
     *   Problems accessing a file.
     */
    private function __construct($rootPath, $new = true)
    {
        $this-&gt;packageExtensions = array_merge(self::TAR_EXTENSIONS, self::ZIP_EXTENSIONS);
        // Define valid hash algorithms our PHP supports.
        $this-&gt;validHashAlgorithms = array_filter(
            hash_algos(),
            array($this, 'filterPhpHashAlgorithms')
        );
        // Alter the algorithm name to the sanitize version.
        array_walk(
            $this-&gt;validHashAlgorithms,
            array($this, 'normalizeHashAlgorithmName')
        );
        $this-&gt;bagRoot = $this-&gt;internalPath($rootPath);
        $this-&gt;loaded = (!$new);
        if ($new) {
            $this-&gt;createNewBag();
        } else {
            $this-&gt;loadBag();
        }
    }

    /**
     * Static function to create a new Bag
     *
     * @param string $rootPath
     *   Path to the new bag, must not exist
     * @return \whikloj\BagItTools\Bag
     *   The bag.
     * @throws \whikloj\BagItTools\BagItException
     *   If we can't create the directory.
     */
    public static function create($rootPath)
    {
        return new Bag($rootPath, true);
    }

    /**
     * Static constructor to load an existing bag.
     *
     * @param string $rootPath
     *   Path to the existing bag.
     * @return \whikloj\BagItTools\Bag
     *   The bag object.
     * @throws \whikloj\BagItTools\BagItException
     *   If we can't read files in the bag.
     */
    public static function load($rootPath)
    {
        if ($rootPath[0] !== DIRECTORY_SEPARATOR) {
            $rootPath = getcwd() . DIRECTORY_SEPARATOR . $rootPath;
        }
        if (is_file($rootPath) &amp;&amp; self::isCompressed($rootPath)) {
            $rootPath = self::uncompressBag($rootPath);
        }
        return new Bag($rootPath, false);
    }

    /**
     * Validate the bag as it appears on disk.
     *
     * @return boolean
     *   True if the bag is valid
     * @throws \whikloj\BagItTools\BagItException
     *   Problems writing to disk.
     */
    public function validate()
    {
        if ($this-&gt;changed) {
            // If we have changed stuff we need to write it.
            $this-&gt;update();
            // Reload the bag from disk.
            $this-&gt;loadBag();
        }
        if (isset($this-&gt;fetchFile)) {
            $this-&gt;fetchFile-&gt;downloadAll();
            $this-&gt;mergeErrors($this-&gt;fetchFile-&gt;getErrors());
        }
        $manifests = array_values($this-&gt;payloadManifests);
        if ($this-&gt;isExtended) {
            // merge in the tag manifests so we can do them all at once.
            $manifests = array_merge($manifests, array_values($this-&gt;tagManifests));
        }
        foreach ($manifests as $manifest) {
            $manifest-&gt;validate();
            $this-&gt;mergeErrors($manifest-&gt;getErrors());
            $this-&gt;mergeWarnings($manifest-&gt;getWarnings());
        }
        return (count($this-&gt;bagErrors) == 0);
    }

    /**
     * Write the updated BagIt files to disk.
     *
     * @throws \whikloj\BagItTools\BagItException
     *   Errors with writing files to disk.
     */
    public function update()
    {
        if (!file_exists($this-&gt;makeAbsolute(&quot;data&quot;))) {
            mkdir($this-&gt;makeAbsolute(&quot;data&quot;), 0777);
        }
        $this-&gt;updateBagIt();
        $this-&gt;updatePayloadManifests();
        $this-&gt;updateFetch();

        if ($this-&gt;isExtended) {
            $this-&gt;updateBagInfo();
            $this-&gt;updateTagManifests();
        } else {
            $this-&gt;removeBagInfo();
            $this-&gt;clearTagManifests();
        }
        $this-&gt;changed = false;
    }

    /**
     * This does cleanup functions related to packaging, for example deleting downloaded files referenced in fetch.txt
     */
    public function finalize()
    {
        // Update files to ensure they are correct.
        $this-&gt;update();
        if (isset($this-&gt;fetchFile)) {
            // Clean up fetch files downloaded to generate checksums.
            $this-&gt;fetchFile-&gt;cleanup();
        }
    }

    /**
     * Package a bag up into an archive.
     *
     * @param string $filepath
     *   The full path to create the archive at.
     * @throws \whikloj\BagItTools\BagItException
     *   Problems creating the archive.
     */
    public function package($filepath)
    {
        $extension = self::getExtensions($filepath);
        if (!in_array($extension, $this-&gt;packageExtensions)) {
            throw new BagItException(
                &quot;Unknown archive type, the file extension must be one of (&quot; .
                implode(&quot;, &quot;, $this-&gt;packageExtensions) . &quot;)&quot;
            );
        }
        $this-&gt;finalize();
        $this-&gt;makePackage($filepath);
    }

    /**
     * Add a file to the bag.
     *
     * @param string $source
     *   Full path to the source file.
     * @param string $dest
     *   Relative path for the destination.
     *
     * @throws \whikloj\BagItTools\BagItException
     *   Source file does not exist or the destination is outside the data directory.
     */
    public function addFile($source, $dest)
    {
        if (file_exists($source)) {
            $dest = BagUtils::baseInData($dest);
            if (!$this-&gt;pathInBagData($dest)) {
                throw new BagItException(&quot;Path {$dest} resolves outside the bag.&quot;);
            } elseif ($this-&gt;reservedFilename($dest)) {
                throw new BagItException(&quot;The filename requested is reserved on Windows OSes.&quot;);
            } elseif (isset($this-&gt;fetchFile) &amp;&amp; $this-&gt;fetchFile-&gt;reservedPath($dest)) {
                throw new BagItException(&quot;The path ({$dest}) is used in the fetch.txt file.&quot;);
            } else {
                $fullDest = $this-&gt;makeAbsolute($dest);
                $fullDest = \Normalizer::normalize($fullDest);
                if (file_exists($fullDest)) {
                    throw new BagItException(&quot;File {$dest} already exists in the bag.&quot;);
                }
                $dirname = dirname($fullDest);
                if (substr($this-&gt;makeRelative($dirname), 0, 5) == &quot;data/&quot;) {
                    // Create any missing missing directories inside data.
                    if (!file_exists($dirname)) {
                        mkdir($dirname, 0777, true);
                    }
                }
                copy($source, $fullDest);
                $this-&gt;changed = true;
            }
        } else {
            throw new BagItException(&quot;{$source} does not exist&quot;);
        }
    }

    /**
     * Remove a payload file.
     *
     * @param string $dest
     *   The relative path of the file.
     */
    public function removeFile($dest)
    {
        $dest = BagUtils::baseInData($dest);
        if ($this-&gt;pathInBagData($dest)) {
            $fullPath = $this-&gt;makeAbsolute($dest);
            if (file_exists($fullPath) &amp;&amp; is_file($fullPath)) {
                unlink($fullPath);
                $this-&gt;checkForEmptyDir($fullPath);
                $this-&gt;changed = true;
            }
        }
    }

    /**
     * Add a string as a file to the bag.
     *
     * @param string $string
     *   The contents of the file.
     * @param string $dest
     *   The name of the file in the bag.
     * @throws \whikloj\BagItTools\BagItException
     *   Source file does not exist or the destination is outside the data directory.
     */
    public function createFile($string, $dest)
    {
        $tempname = tempnam(&quot;&quot;, &quot;bagit_&quot;);
        unlink($tempname);
        file_put_contents($tempname, $string);
        try {
            $this-&gt;addFile($tempname, $dest);
        } finally {
            unlink($tempname);
        }
    }

    /**
     * Add the bag root to the front of a relative bag path and return with
     * OS directory separator.
     *
     * @param string $path
     *   The relative path.
     * @return string
     *   The absolute path.
     */
    public function makeAbsolute($path)
    {
        $length = strlen($this-&gt;bagRoot);
        $path = $this-&gt;internalPath($path);
        if (substr($path, 0, $length) == $this-&gt;bagRoot) {
            return $path;
        }
        $components = array_filter(explode(&quot;/&quot;, $path));
        $rootComponents = array_filter(explode(&quot;/&quot;, $this-&gt;bagRoot));
        $components = array_merge($rootComponents, $components);
        return DIRECTORY_SEPARATOR . implode(DIRECTORY_SEPARATOR, $components);
    }

    /**
     * Remove all the extraneous path information and make relative to bag root.
     *
     * @param string $path
     *   The absolute path to process
     * @return string
     *   The shortened path or blank if it is outside bag root.
     */
    public function makeRelative($path)
    {
        $path = $this-&gt;internalPath($path);
        $path = BagUtils::getAbsolute($path);
        $rootLength = strlen($this-&gt;bagRoot);
        if (substr($path, 0, $rootLength) !== $this-&gt;bagRoot) {
            // We are not in bag root so return nothing.
            return '';
        }
        return substr($path, strlen($this-&gt;bagRoot) + 1);
    }

    /**
     * Return raw bag info data.
     *
     * @return array
     *   Bag Info data.
     */
    public function getBagInfoData()
    {
        return $this-&gt;bagInfoData;
    }

    /**
     * Case-insensitive search of bag-info tags.
     * @param string $tag
     *   Bag info tag to locate
     * @return bool
     *   Does the tag exist.
     */
    public function hasBagInfoTag($tag)
    {
        $tag = self::trimLower($tag);
        return $this-&gt;bagInfoTagExists($tag);
    }

    /**
     * Find all instances of tag and return an array of values.
     *
     * @param string $tag
     *   Bag info tag to locate
     * @return array
     *   Array of values for the tag.
     */
    public function getBagInfoByTag($tag)
    {
        $tag = self::trimLower($tag);
        if ($this-&gt;bagInfoTagExists($tag)) {
            return $this-&gt;bagInfoTagIndex[$tag];
        }
        return [];
    }

    /**
     * Remove ALL instances of tag.
     *
     * @param string $tag
     *   The tag to remove.
     */
    public function removeBagInfoTag($tag)
    {
        $tag = self::trimLower($tag);
        if ($this-&gt;bagInfoTagExists($tag)) {
            $newInfo = [];
            foreach ($this-&gt;bagInfoData as $row) {
                $rowTag = self::trimLower($row['tag']);
                if ($rowTag !== $tag) {
                    $newInfo[] = $row;
                }
            }
            $this-&gt;bagInfoData = $newInfo;
            $this-&gt;updateBagInfoIndex();
            $this-&gt;changed = true;
        }
    }

    /**
     * Removes a specific entry for a tag by the array index. This can be determined using the index in the array
     * returned by getBagInfoByKey().
     *
     * @param string $tag
     *   The tag to remove.
     * @param int $index
     *   The index of the value to remove.
     */
    public function removeBagInfoTagIndex($tag, $index)
    {
        if (is_int($index) &amp;&amp; $index &gt; -1) {
            $tag = self::trimLower($tag);
            if ($this-&gt;bagInfoTagExists($tag)) {
                $values = $this-&gt;getBagInfoByTag($tag);
                if ($index &lt; count($values)) {
                    $newInfo = [];
                    $tagCount = 0;
                    foreach ($this-&gt;bagInfoData as $row) {
                        $rowTag = self::trimLower($row['tag']);
                        if ($rowTag !== $tag || $tagCount !== $index) {
                            $newInfo[] = $row;
                        }
                        if ($rowTag == $tag) {
                            $tagCount += 1;
                        }
                    }
                    $this-&gt;bagInfoData = $newInfo;
                    $this-&gt;updateBagInfoIndex();
                    $this-&gt;changed = true;
                }
            }
        }
    }

    /**
     * Add tag and value to bag-info.
     *
     * @param string $tag
     *   The tag to add.
     * @param string $value
     *   The value to add.
     * @throws \whikloj\BagItTools\BagItException
     *   When you try to set an auto-generated tag value.
     */
    public function addBagInfoTag($tag, $value)
    {
        $internal_tag = self::trimLower($tag);
        if (in_array($internal_tag, self::BAG_INFO_GENERATED_ELEMENTS)) {
            throw new BagItException(&quot;Field {$tag} is auto-generated and cannot be manually set.&quot;);
        }
        if (!$this-&gt;bagInfoTagExists($internal_tag)) {
            $this-&gt;bagInfoTagIndex[$internal_tag] = [];
        }
        $this-&gt;bagInfoTagIndex[$internal_tag][] = $value;
        $this-&gt;bagInfoData[] = [
            'tag' =&gt; trim($tag),
            'value' =&gt; trim($value),
        ];
        $this-&gt;changed = true;
    }

    /**
     * Set the file encoding.
     *
     * @param string $encoding
     *   The MIME name of the character set to encode with.
     * @throws \whikloj\BagItTools\BagItException
     *   If we don't support the requested character set.
     */
    public function setFileEncoding($encoding)
    {
        $encoding = self::trimLower($encoding);
        $charset = BagUtils::getValidCharset($encoding);
        if (is_null($charset)) {
            throw new BagItException(&quot;Character set {$encoding} is not supported.&quot;);
        } else {
            if ($encoding == self::trimLower(self::DEFAULT_FILE_ENCODING)) {
                // go back to default.
                unset($this-&gt;currentFileEncoding);
            } else {
                $this-&gt;currentFileEncoding = $charset;
            }
            $this-&gt;changed = true;
        }
    }

    /**
     * Get current file encoding or default if not specified.
     *
     * @return string
     *   Current file encoding.
     */
    public function getFileEncoding()
    {
        if (isset($this-&gt;currentFileEncoding)) {
            return $this-&gt;currentFileEncoding;
        }
        return self::DEFAULT_FILE_ENCODING;
    }

    /**
     * Get the currently active payload (and tag) manifests.
     *
     * @return array
     *   Internal hash names for current manifests.
     */
    public function getAlgorithms()
    {
        return array_keys($this-&gt;payloadManifests);
    }

    /**
     * Do we have this hash algorithm already?
     *
     * @param string $hashAlgorithm
     *   The requested hash algorithms.
     *
     * @return boolean Do we already have this payload manifest.
     */
    public function hasAlgorithm($hashAlgorithm)
    {
        $internal_name = $this-&gt;getHashName($hashAlgorithm);
        if ($this-&gt;hashIsSupported($internal_name)) {
            return $this-&gt;hasHash($internal_name);
        }
        return false;
    }

    /**
     * The algorithm is supported.
     *
     * @param string $algorithm
     *   The requested hash algorithm
     * @return boolean
     *   Whether it is supported by our PHP.
     */
    public function algorithmIsSupported($algorithm)
    {
        $internal_name = $this-&gt;getHashName($algorithm);
        return $this-&gt;hashIsSupported($internal_name);
    }

    /**
     * Add a hash algorithm to the bag.
     *
     * @param string $algorithm
     *   Algorithm to add.
     * @throws \whikloj\BagItTools\BagItException
     *   Asking for an unsupported algorithm.
     */
    public function addAlgorithm($algorithm)
    {
        $internal_name = $this-&gt;getHashName($algorithm);
        if ($this-&gt;hashIsSupported($internal_name)) {
            if (!array_key_exists($internal_name, $this-&gt;payloadManifests)) {
                $this-&gt;payloadManifests[$internal_name] = new PayloadManifest($this, $internal_name);
            }
            if ($this-&gt;isExtended) {
                $this-&gt;ensureTagManifests();
                if (!array_key_exists($internal_name, $this-&gt;tagManifests)) {
                    $this-&gt;tagManifests[$internal_name] = new TagManifest($this, $internal_name);
                }
            }
            $this-&gt;changed = true;
        } else {
            throw new BagItException(&quot;Algorithm {$algorithm} is not supported.&quot;);
        }
    }

    /**
     * Remove a hash algorithm from the bag.
     *
     * @param string $algorithm
     *   Algorithm to remove
     * @throws \whikloj\BagItTools\BagItException
     *   Trying to remove the last algorithm or asking for an unsupported algorithm.
     */
    public function removeAlgorithm($algorithm)
    {
        $internal_name = $this-&gt;getHashName($algorithm);
        if ($this-&gt;hashIsSupported($internal_name)) {
            if (array_key_exists($internal_name, $this-&gt;payloadManifests)) {
                if (count($this-&gt;payloadManifests) == 1) {
                    throw new BagItException(&quot;Cannot remove last payload algorithm, add one before removing this one&quot;);
                }
                $this-&gt;removePayloadManifest($internal_name);
            }
            if ($this-&gt;isExtended &amp;&amp; isset($this-&gt;tagManifests) &amp;&amp;
                array_key_exists($internal_name, $this-&gt;tagManifests)) {
                if (count($this-&gt;tagManifests) == 1) {
                    throw new BagItException(&quot;Cannot remove last tag algorithm, add one before removing this one&quot;);
                }
                $this-&gt;removeTagManifest($internal_name);
            }
            $this-&gt;changed = true;
        } else {
            throw new BagItException(&quot;Algorithm {$algorithm} is not supported.&quot;);
        }
    }

    /**
     * Replaces any existing hash algorithms with the one requested.
     *
     * @param string $algorithm
     *   Algorithm to use.
     * @throws \whikloj\BagItTools\BagItException
     *   Asking for an unsupported algorithm.
     */
    public function setAlgorithm($algorithm)
    {
        $internal_name = $this-&gt;getHashName($algorithm);
        if ($this-&gt;hashIsSupported($internal_name)) {
            $this-&gt;removeAllPayloadManifests([$internal_name]);
            if (count($this-&gt;payloadManifests) == 0) {
                $this-&gt;payloadManifests[$internal_name] = new PayloadManifest($this, $internal_name);
            }
            $this-&gt;removeAllTagManifests([$internal_name]);
            if ($this-&gt;isExtended) {
                $this-&gt;ensureTagManifests();
                if (count($this-&gt;tagManifests) == 0) {
                    $this-&gt;tagManifests[$internal_name] = new TagManifest($this, $internal_name);
                }
            }
            $this-&gt;changed = true;
        } else {
            throw new BagItException(&quot;Algorithm {$algorithm} is not supported.&quot;);
        }
    }

    /**
     * Add a file to your fetch file.
     *
     * @param string $url
     *   The source URL.
     * @param string $destination
     *   The destination path in the bag.
     * @param null|integer $size
     *   Size of the file to be stored in the fetch file, if desired.
     * @throws \whikloj\BagItTools\BagItException
     *   On errors adding the file.
     */
    public function addFetchFile($url, $destination, $size = null)
    {
        $fetchData = [
            'uri' =&gt; $url,
            'destination' =&gt; $destination,
        ];
        if (!is_null($size)) {
            $fetchData['size'] = $size;
        }
        if (!isset($this-&gt;fetchFile)) {
            $this-&gt;fetchFile = new Fetch($this, false);
        }
        // Download the file now to help with manifest handling, deleted when you package() or finalize().
        $this-&gt;fetchFile-&gt;download($fetchData);
        $this-&gt;changed = true;
    }

    /**
     * Return the fetch file data, an array of arrays with keys 'url', 'destination' and (optionally) 'size'.
     *
     * @return array
     */
    public function listFetchFiles()
    {
        return (!isset($this-&gt;fetchFile) ? [] : $this-&gt;fetchFile-&gt;getData());
    }

    /**
     * Wipe the fetch file data
     */
    public function clearFetch()
    {
        if (isset($this-&gt;fetchFile)) {
            $this-&gt;fetchFile-&gt;clearData();
            unset($this-&gt;fetchFile);
            $this-&gt;changed = true;
        }
    }

    /**
     * Delete a line from the fetch file.
     *
     * @param string $url
     *   The url to delete.
     */
    public function removeFetchFile($url)
    {
        if (isset($this-&gt;fetchFile)) {
            $this-&gt;fetchFile-&gt;removeFile($url);
            $this-&gt;changed = true;
        }
    }

    /**
     * Get the current version array or default if not specified.
     *
     * @return array
     *   Current version.
     */
    public function getVersion()
    {
        if (isset($this-&gt;currentVersion)) {
            return $this-&gt;currentVersion;
        }
        return self::DEFAULT_BAGIT_VERSION;
    }

    /**
     * Get current version as string.
     *
     * @return string
     *   Current version in M.N format.
     */
    public function getVersionString()
    {
        $version = $this-&gt;getVersion();
        return $version['major'] . &quot;.&quot; . $version['minor'];
    }

    /**
     * Return path to the bag root.
     *
     * @return string
     *   The bag root path.
     */
    public function getBagRoot()
    {
        return $this-&gt;bagRoot;
    }

    /**
     * Return path to the data directory.
     *
     * @return string
     *   The bag data directory path.
     */
    public function getDataDirectory()
    {
        return $this-&gt;makeAbsolute(&quot;data&quot;);
    }

    /**
     * Check the bag's extended status.
     *
     * @return boolean
     *   Does the bag use extended features?
     */
    public function isExtended()
    {
        return $this-&gt;isExtended;
    }

    /**
     * Turn extended bag features on or off.
     *
     * @param boolean $extBag
     *   Whether the bag should be extended or not.
     */
    public function setExtended($extBag)
    {
        $extBag = (bool) $extBag;
        $this-&gt;isExtended = $extBag;
        $this-&gt;changed = true;
    }

    /**
     * Get errors on the bag.
     *
     * @return array
     *   The errors.
     */
    public function getErrors()
    {
        return $this-&gt;bagErrors;
    }

    /**
     * Get any warnings related to the bag.
     *
     * @return array
     *   The warnings.
     */
    public function getWarnings()
    {
        return $this-&gt;bagWarnings;
    }

    /**
     * Get the payload manifests as an associative array with hash algorithm as key.
     *
     * @return array
     *   hash algorithm =&gt; Payload manifests
     */
    public function getPayloadManifests()
    {
        return $this-&gt;payloadManifests;
    }

    /**
     * Get the tag manifests as an associative array with hash algorithm as key.
     *
     * @return array|null
     *   hash algorithm =&gt; Tag manifests or null if not an extended bag.
     */
    public function getTagManifests()
    {
        return (isset($this-&gt;tagManifests) ? $this-&gt;tagManifests : null);
    }

    /**
     * Utility function to convert text to UTF-8
     * @param string $text
     *   The source text.
     * @return string
     *   The converted text.
     */
    public function decodeText($text)
    {
        return mb_convert_encoding($text, self::DEFAULT_FILE_ENCODING, $this-&gt;getFileEncoding());
    }

    /**
     * Utility function to convert text back to the encoding for the file.
     *
     * @param string $text
     *   The source text.
     * @return string
     *   The converted text.
     */
    public function encodeText($text)
    {
        return mb_convert_encoding($text, $this-&gt;getFileEncoding(), self::DEFAULT_FILE_ENCODING);
    }

    /**
     * Is the path inside the payload directory?
     *
     * @param string $filepath
     *   The internal path.
     * @return boolean
     *   Path is inside the data/ directory.
     */
    public function pathInBagData($filepath)
    {
        $external = $this-&gt;makeAbsolute($filepath);
        $external = trim($external);
        $external = BagUtils::getAbsolute($external);
        $relative = $this-&gt;makeRelative($external);
        return ($relative !== &quot;&quot; &amp;&amp; substr($relative, 0, 5) === &quot;data/&quot;);
    }


    /**
     * Check the directory we just deleted a file from, if empty we should remove
     * it too.
     *
     * @param string $path
     *   The file just deleted.
     */
    public function checkForEmptyDir($path)
    {
        $parentPath = dirname($path);
        if (substr($this-&gt;makeRelative($parentPath), 0, 5) == &quot;data/&quot;) {
            $files = scandir($parentPath);
            $payload = array_filter($files, function ($o) {
                // Don't count directory specifiers.
                return (!BagUtils::isDotDir($o));
            });
            if (count($payload) == 0) {
                rmdir($parentPath);
            }
        }
    }

    /**
     * Upgrade an older bag to comply with the 1.0 specification.
     *
     * @throws \whikloj\BagItTools\BagItException
     *   If the bag cannot be upgraded for some reason.
     */
    public function upgrade()
    {
        if (!$this-&gt;loaded) {
            throw new BagItException(&quot;You can only upgrade loaded bags.&quot;);
        } elseif ($this-&gt;getVersion() == self::DEFAULT_BAGIT_VERSION) {
            throw new BagItException(&quot;Bag is already at version {$this-&gt;getVersionString()}&quot;);
        } elseif (!$this-&gt;validate()) {
            throw new BagItException(&quot;This bag is not valid, we cannot automatically upgrade it.&quot;);
        } else {
            // We can upgrade.
            $hashes = array_keys($this-&gt;getPayloadManifests());
            if (count($hashes) == 1 &amp;&amp; $hashes[0] == 'md5') {
                $this-&gt;setAlgorithm(self::DEFAULT_HASH_ALGORITHM);
            }
            unset($this-&gt;currentVersion);
            $this-&gt;update();
        }
    }

    /*
     *  XXX: Private functions
     */

    /**
     * Load a bag from disk.
     *
     * @throws \whikloj\BagItTools\BagItException
     *   If a file cannot be read.
     */
    private function loadBag()
    {
        $root = $this-&gt;getBagRoot();
        if (!file_exists($root)) {
            throw new BagItException(&quot;Path {$root} does not exist, could not load Bag.&quot;);
        }
        $this-&gt;bagErrors = [];
        $this-&gt;bagWarnings = [];
        // Reset these or we end up with double manifests in a validate() situation.
        $this-&gt;payloadManifests = [];
        unset($this-&gt;tagManifests);
        $this-&gt;loadBagIt();
        $this-&gt;loadPayloadManifests();
        $bagInfo = $this-&gt;loadBagInfo();
        $tagManifest = $this-&gt;loadTagManifests();
        $this-&gt;loadFetch();
        $this-&gt;isExtended = ($bagInfo || $tagManifest);
    }

    /**
     * Create a new bag and output the default parts.
     */
    private function createNewBag()
    {
        $this-&gt;bagErrors = [];
        $this-&gt;bagRoot = BagUtils::getAbsolute($this-&gt;bagRoot);
        if (file_exists($this-&gt;bagRoot)) {
            throw new BagItException(&quot;New bag directory {$this-&gt;bagRoot} exists&quot;);
        }
        mkdir($this-&gt;bagRoot . DIRECTORY_SEPARATOR . &quot;data&quot;, 0777, true);
        $this-&gt;updateBagIt();
        $this-&gt;payloadManifests = [
            self::DEFAULT_HASH_ALGORITHM =&gt; new PayloadManifest($this, self::DEFAULT_HASH_ALGORITHM)
        ];
    }

    /**
     * Update a fetch.txt if it exists.
     *
     * @throws \whikloj\BagItTools\BagItException
     */
    private function updateFetch()
    {
        if (isset($this-&gt;fetchFile)) {
            $this-&gt;fetchFile-&gt;update();
        }
    }

    /**
     * Read in the bag-info.txt file.
     *
     * @return boolean
     *   Does bag-info.txt exists.
     *
     * @throws \whikloj\BagItTools\BagItException
     *   Unable to read bag-info.txt
     */
    private function loadBagInfo()
    {
        $info_file = 'bag-info.txt';
        $fullPath = $this-&gt;makeAbsolute($info_file);
        if (file_exists($fullPath)) {
            $fp = fopen($fullPath, 'rb');
            if ($fp === false) {
                throw new BagItException(&quot;Unable to access {$info_file}&quot;);
            }
            $bagData = [];
            $lineCount = 0;
            while (!feof($fp)) {
                $line = fgets($fp);
                $lineCount += 1;
                if ($line == &quot;&quot;) {
                    continue;
                }
                $line = $this-&gt;decodeText($line);

                if (preg_match(&quot;~^(\s+)?([^:]+?)(\s+)?:\s+(.*)$~&quot;, $line, $matches)) {
                    // First line
                    $current_tag = $matches[2];
                    if ($this-&gt;mustNotRepeatBagInfoExists($current_tag)) {
                        $this-&gt;addBagError(
                            $info_file,
                            &quot;Tag {$current_tag} MUST not be repeated. (Line {$lineCount})&quot;
                        );
                    } elseif ($this-&gt;shouldNotRepeatBagInfoExists($current_tag)) {
                        $this-&gt;addBagWarning(
                            $info_file,
                            &quot;Tag {$current_tag} SHOULD NOT be repeated. (Line {$lineCount})&quot;
                        );
                    }
                    if (($this-&gt;compareVersion('1.0') &lt;=0) &amp;&amp; (!empty($matches[1]) || !empty($matches[3]))) {
                        $this-&gt;addBagError(
                            $info_file,
                            &quot;Labels cannot begin or end with a whitespace. (Line {$lineCount})&quot;
                        );
                    }
                    $bagData[] = [
                        'tag' =&gt; $current_tag,
                        'value' =&gt; trim($matches[4]),
                    ];
                } elseif (!empty($line) &amp;&amp; ($line[0] == &quot; &quot; || $line[0] == &quot;\t&quot;)) {
                    if (count($bagData) &gt; 0) {
                        $bagData[count($bagData)-1]['value'] .= &quot; &quot; . trim($line);
                    }
                } elseif (!empty($line)) {
                    $this-&gt;addBagError($info_file, &quot;Invalid tag.&quot;);
                }
            }
            fclose($fp);
            $this-&gt;bagInfoData = $bagData;
            $this-&gt;updateBagInfoIndex();
            return true;
        }
        return false;
    }

    /**
     * Return a trimmed and lowercase version of text.
     * @param string $text
     *   The original text.
     * @return string
     *   The lowercase trimmed text.
     */
    private static function trimLower($text)
    {
        $text = strtolower($text);
        return trim($text);
    }

    /**
     * Generate a faster index of Bag-Info tags.
     */
    private function updateBagInfoIndex()
    {
        $tags = [];
        foreach ($this-&gt;bagInfoData as $row) {
            $tagName = self::trimLower($row['tag']);
            if (!array_key_exists($tagName, $tags)) {
                $tags[$tagName] = [];
            }
            $tags[$tagName][] = $row['value'];
        }
        $this-&gt;bagInfoTagIndex = $tags;
    }

    /**
     * Internal case insensitive search of bag info.
     *
     * @param string $internal_tag
     *   Trimmed and lowercase tag.
     * @return bool
     *   Does it exist in the index.
     */
    private function bagInfoTagExists($internal_tag)
    {
        return array_key_exists($internal_tag, $this-&gt;bagInfoTagIndex);
    }

    /**
     * Write the contents of the bag-info array to disk.
     *
     * @throws \whikloj\BagItTools\BagItException
     *   Can't write the file to disk.
     */
    private function updateBagInfo()
    {
        $fullPath = $this-&gt;makeAbsolute(&quot;bag-info.txt&quot;);
        $fp = fopen($fullPath, 'wb');
        if ($fp === false) {
            throw new BagItException(&quot;Could not write bag-info.txt&quot;);
        }
        $this-&gt;updateCalculateBagInfoFields();
        $this-&gt;updateBagInfoIndex();
        foreach ($this-&gt;bagInfoData as $bag_info_datum) {
            $tag = $bag_info_datum['tag'];
            $value = $bag_info_datum['value'];
            $data = self::wrapBagInfoText(&quot;{$tag}: {$value}&quot;);
            foreach ($data as $line) {
                $line = $this-&gt;encodeText($line);
                fwrite($fp, $line . PHP_EOL);
            }
        }
        fclose($fp);
    }

    /**
     * Update the calculated bag-info fields
     */
    private function updateCalculateBagInfoFields()
    {
        $newInfo = [];
        foreach ($this-&gt;bagInfoData as $row) {
            if (in_array(self::trimLower($row['tag']), self::BAG_INFO_GENERATED_ELEMENTS)) {
                continue;
            }
            $newInfo[] = $row;
        }
        $oxum = $this-&gt;calculateOxum();
        if (!is_null($oxum)) {
            $newInfo[] = [
                'tag' =&gt; 'Payload-Oxum',
                'value' =&gt; $oxum,
            ];
        }
        $newInfo[] = [
            'tag' =&gt; 'Bagging-Date',
            'value' =&gt; date('Y-m-d', time()),
        ];
        $this-&gt;bagInfoData = $newInfo;
    }

    /**
     * Remove the bag-info.txt file and data.
     */
    private function removeBagInfo()
    {
        $fullPath = $this-&gt;makeAbsolute('bag-info.txt');
        if (file_exists($fullPath)) {
            unlink($fullPath);
        }
        $this-&gt;bagInfoData = [];
    }

    /**
     * Calculate the payload-oxum value for all payload files.
     *
     * @return string|null
     *   The payload-oxum or null if we couldn't read all the file sizes.
     */
    private function calculateOxum()
    {
        $total_size = 0;
        $total_files = 0;
        foreach ($this-&gt;payloadFiles as $file) {
            $fullPath = $this-&gt;makeAbsolute($file);
            if (file_exists($fullPath) &amp;&amp; is_file($fullPath)) {
                $info = stat($fullPath);
                if (isset($info[7])) {
                    $total_size += (int) $info[7];
                } else {
                    return null;
                }
                $total_files += 1;
            }
        }
        return &quot;{$total_size}.{$total_files}&quot;;
    }

    /**
     * Wrap bagInfo lines to 79 characters if possible
     *
     * @param string $text
     *   The whole tag and value as one.
     * @return array
     *   The text as an array.
     */
    private static function wrapBagInfoText($text)
    {
        // Start at 78 for some leeway.
        $length = 78;
        do {
            $rows = self::wrapAtLength($text, $length);
            $too_long = array_filter($rows, function ($o) {
                return strlen($o) &gt; 78;
            });
            $length -= 1;
        } while ($length &gt; 0 &amp;&amp; count($too_long) &gt; 0);
        if (count($too_long) &gt; 0) {
            // No matter the size we couldn't get it to fit in 79 characters. So we give up.
            $rows = self::wrapAtLength($text, 78);
        }
        for ($foo = 1; $foo &lt; count($rows); $foo += 1) {
            $rows[$foo] = &quot;  &quot; . $rows[$foo];
        }
        return $rows;
    }

    /**
     * Utility to remove newline characters, wrap the string and return an array of the rows.
     * @param string $text
     *   The text to wrap.
     * @param int $length
     *   The length to wrap at.
     * @return array
     *   Rows of text.
     */
    private static function wrapAtLength($text, $length)
    {
        $text = str_replace(&quot;\n&quot;, &quot;&quot;, $text);
        $wrapped = wordwrap($text, $length, &quot;\n&quot;);
        return explode(&quot;\n&quot;, $wrapped);
    }

    /**
     * Load all tag manifests (if any).
     *
     * @return boolean
     *   Are there any tag manifest files.
     *
     * @throws \whikloj\BagItTools\BagItException
     *   Problems with glob() pattern or loading manifest.
     */
    private function loadTagManifests()
    {
        $tagManifests = [];
        $pattern = $this-&gt;getBagRoot() . DIRECTORY_SEPARATOR . &quot;tagmanifest-*.txt&quot;;
        $files = BagUtils::findAllByPattern($pattern);
        if (count($files) &gt; 0) {
            foreach ($files as $file) {
                $hash = self::determineHashFromFilename($file);
                if (isset($tagManifests[$hash])) {
                    $this-&gt;addBagError(
                        $this-&gt;makeRelative($file),
                        &quot;More than one tag manifest for hash ({$hash}) found.&quot;
                    );
                } else {
                    $tagManifests[$hash] = new TagManifest($this, $hash, true);
                }
            }
            $this-&gt;tagManifests = $tagManifests;
            return true;
        }
        return false;
    }

    /**
     * Utility to setup tag manifests.
     */
    private function ensureTagManifests()
    {
        if (!isset($this-&gt;tagManifests)) {
            $this-&gt;tagManifests = [];
        }
    }

    /**
     * Run update against the tag manifests.
     */
    private function updateTagManifests()
    {
        if ($this-&gt;isExtended) {
            $this-&gt;clearTagManifests();
            $this-&gt;ensureTagManifests();
            $hashes = (is_array($this-&gt;payloadManifests) ? $this-&gt;payloadManifests :
                [self::DEFAULT_HASH_ALGORITHM =&gt; &quot;&quot;]);
            $hashes = array_diff_key($hashes, $this-&gt;tagManifests);
            foreach (array_keys($hashes) as $hash) {
                $this-&gt;tagManifests[$hash] = new TagManifest($this, $hash);
            }
            foreach ($this-&gt;tagManifests as $manifest) {
                $manifest-&gt;update();
            }
        }
    }

    /**
     * Remove all tagmanifest files.
     *
     * @throws \whikloj\BagItTools\BagItException
     *    Errors with glob() pattern.
     */
    private function clearTagManifests()
    {
        $pattern = $this-&gt;getBagRoot() . DIRECTORY_SEPARATOR . &quot;tagmanifest-*.txt&quot;;
        $this-&gt;clearFilesOfPattern($pattern);
        unset($this-&gt;tagManifests);
    }

    /**
     * Remove tag manifests.
     *
     * @param array $exclusions
     *   Hash algorithm names of manifests to preserve.
     */
    private function removeAllTagManifests($exclusions = [])
    {
        if (isset($this-&gt;tagManifests)) {
            foreach ($this-&gt;tagManifests as $hash =&gt; $manifest) {
                if (in_array($hash, $exclusions)) {
                    continue;
                }
                $this-&gt;removeTagManifest($hash);
            }
        }
    }

    /**
     * Remove a single tag manifest.
     *
     * @param string $internal_name
     *   The hash name to remove.
     */
    private function removeTagManifest($internal_name)
    {
        $manifest = $this-&gt;tagManifests[$internal_name];
        $filename = $manifest-&gt;getFilename();
        if (file_exists($filename)) {
            unlink($this-&gt;makeAbsolute($filename));
        }
        unset($this-&gt;tagManifests[$internal_name]);
    }

    /**
     * Load all payload manifests found on disk.
     *
     * @throws \whikloj\BagItTools\BagItException
     *   Problems with glob() pattern or loading manifest.
     */
    private function loadPayloadManifests()
    {
        $pattern = $this-&gt;getBagRoot() . DIRECTORY_SEPARATOR . &quot;manifest-*.txt&quot;;
        $manifests = BagUtils::findAllByPattern($pattern);
        if (count($manifests) == 0) {
            $this-&gt;addBagError('manifest-ALG.txt', 'No payload manifest files found.');
        } else {
            $files = [];
            foreach ($manifests as $manifest) {
                $hash = self::determineHashFromFilename($manifest);
                $relative_filename = $this-&gt;makeRelative($manifest);
                if (!is_null($hash) &amp;&amp; !in_array($hash, array_keys(self::HASH_ALGORITHMS))) {
                    throw new BagItException(&quot;We do not support the algorithm {$hash}&quot;);
                } elseif (is_null($hash)) {
                    $this-&gt;addBagError(
                        $relative_filename,
                        &quot;Payload manifest MUST have a name in the form of manifest-ALG.txt&quot;
                    );
                } elseif (isset($this-&gt;payloadManifests[$hash])) {
                    $this-&gt;addBagError(
                        $relative_filename,
                        &quot;More than one payload manifest for hash ({$hash}) found.&quot;
                    );
                } else {
                    $temp = new PayloadManifest($this, $hash, true);
                    $this-&gt;payloadManifests[$hash] = $temp;
                    $files = array_merge($files, array_keys($temp-&gt;getHashes()));
                }
            }
            $this-&gt;payloadFiles = array_unique($files);
        }
    }

    /**
     * Run update against the payload manifests.
     */
    private function updatePayloadManifests()
    {
        if (!isset($this-&gt;payloadManifests)) {
            $manifest = new PayloadManifest($this, self::DEFAULT_HASH_ALGORITHM);
            $this-&gt;payloadManifests = [self::DEFAULT_HASH_ALGORITHM =&gt; $manifest];
        }
        // Delete all manifest files, before we update the current manifests.
        $this-&gt;clearPayloadManifests();
        $files = [];
        foreach ($this-&gt;payloadManifests as $manifest) {
            $manifest-&gt;update();
            $files = array_merge($files, array_keys($manifest-&gt;getHashes()));
        }
        $this-&gt;payloadFiles = array_unique($files);
    }

    /**
     * Remove all manifest files.
     *
     * @throws \whikloj\BagItTools\BagItException
     *    Errors with glob() pattern.
     */
    private function clearPayloadManifests()
    {
        $pattern = $this-&gt;getBagRoot() . DIRECTORY_SEPARATOR . &quot;manifest-*.txt&quot;;
        $this-&gt;clearFilesOfPattern($pattern);
    }

    /**
     * Remove payload manifests.
     *
     * @param array $exclusions
     *   Hash algorithm names of manifests to preserve.
     */
    private function removeAllPayloadManifests($exclusions = [])
    {
        foreach ($this-&gt;payloadManifests as $hash =&gt; $manifest) {
            if (in_array($hash, $exclusions)) {
                continue;
            }
            $this-&gt;removePayloadManifest($hash);
        }
    }

    /**
     * Remove a single payload manifest.
     *
     * @param string $internal_name
     *   The hash name to remove.
     */
    private function removePayloadManifest($internal_name)
    {
        $manifest = $this-&gt;payloadManifests[$internal_name];
        $filename = $manifest-&gt;getFilename();
        if (file_exists($filename)) {
            unlink($this-&gt;makeAbsolute($filename));
        }
        unset($this-&gt;payloadManifests[$internal_name]);
    }

    /**
     * Load the bagit.txt on disk.
     *
     * @throws \whikloj\BagItTools\BagItException
     *   Can't read the file on disk.
     */
    private function loadBagIt()
    {
        $fullPath = $this-&gt;makeAbsolute(&quot;bagit.txt&quot;);
        if (!file_exists($fullPath)) {
            $this-&gt;bagErrors[] = [
                'file' =&gt; 'bagit.txt',
                'message' =&gt; 'Required file missing.',
            ];
        } else {
            $contents = file_get_contents($fullPath);
            if ($contents === false) {
                throw new BagItException(&quot;Unable to read {$fullPath}&quot;);
            }
            $contents = $this-&gt;decodeText($contents);
            $lines = explode(PHP_EOL, $contents);
            //$lines = preg_split(&quot;~[\r\n]+~&quot;, $contents, null, PREG_SPLIT_NO_EMPTY);
            // remove blank lines.
            $lines = array_filter($lines);
            array_walk($lines, function (&amp;$item) {
                $item = trim($item);
            });
            if (count($lines) !== 2) {
                $this-&gt;bagErrors[] = [
                    'file' =&gt; 'bagit.txt',
                    'message' =&gt; sprintf(
                        &quot;File MUST contain exactly 2 lines, found %b&quot;,
                        count($lines)
                    ),
                ];
            } else {
                if (!preg_match(
                    &quot;~^BagIt\-Version: (\d+)\.(\d+)$~&quot;,
                    $lines[0],
                    $match
                )) {
                    $this-&gt;bagErrors[] = [
                        'file' =&gt; 'bagit.txt',
                        'message' =&gt; 'First line should have pattern BagIt-Version: M.N',
                    ];
                } else {
                    $this-&gt;currentVersion = [
                        'major' =&gt; $match[1],
                        'minor' =&gt; $match[2],
                    ];
                }
                if (!preg_match(
                    &quot;~^Tag\-File\-Character\-Encoding: (.*)$~&quot;,
                    $lines[1],
                    $match
                )) {
                    $this-&gt;bagErrors[] = [
                        'file' =&gt; 'bagit.txt',
                        'message' =&gt; 'Second line should have pattern ' .
                            'Tag-File-Character-Encoding: ENCODING',
                    ];
                } else {
                    $this-&gt;currentFileEncoding = $match[1];
                }
            }
        }
    }

    /**
     * Update the bagit.txt on disk.
     */
    private function updateBagIt()
    {
        $version = $this-&gt;getVersion();

        $output = sprintf(
            &quot;BagIt-Version: %d.%d&quot; . PHP_EOL .
            &quot;Tag-File-Character-Encoding: %s&quot; . PHP_EOL,
            $version['major'],
            $version['minor'],
            $this-&gt;getFileEncoding()
        );

        // We don't use encodeText because this must always be UTF-8.
        $output = mb_convert_encoding($output, self::DEFAULT_FILE_ENCODING);

        file_put_contents(
            $this-&gt;makeAbsolute(&quot;bagit.txt&quot;),
            $output
        );
    }

    /**
     * Load a fetch.txt if it exists.
     */
    private function loadFetch()
    {
        $fullPath = $this-&gt;makeAbsolute('fetch.txt');
        if (file_exists($fullPath)) {
            $this-&gt;fetchFile = new Fetch($this, true);
            $this-&gt;bagErrors = array_merge($this-&gt;bagErrors, $this-&gt;fetchFile-&gt;getErrors());
        }
    }

    /**
     * Create an archive file of the current bag.
     *
     * @param string $filename
     *   The archive filename.
     * @throws \whikloj\BagItTools\BagItException
     *   Problems creating the archive.
     */
    private function makePackage($filename)
    {
        $extension = self::getExtensions($filename);
        if (in_array($extension, self::ZIP_EXTENSIONS)) {
            $this-&gt;makeZip($filename);
        } elseif (in_array($extension, self::TAR_EXTENSIONS)) {
            $this-&gt;makeTar($filename);
        } else {
            throw new BagItException(&quot;Unable to determine archive format.&quot;);
        }
    }

    /**
     * Create a Zip archive.
     *
     * @param string $filename
     *   The archive filename.
     * @throws \whikloj\BagItTools\BagItException
     *   Problems creating the archive.
     */
    private function makeZip($filename)
    {
        $zip = new \ZipArchive;
        $res = $zip-&gt;open($filename, \ZipArchive::CREATE);
        if ($res === true) {
            $files = BagUtils::getAllFiles($this-&gt;bagRoot);
            $parentPrefix = basename($this-&gt;bagRoot);
            foreach ($files as $file) {
                $relative = $this-&gt;makeRelative($file);
                $zip-&gt;addFile($file, &quot;{$parentPrefix}/{$relative}&quot;);
            }
            $zip-&gt;close();
        } else {
            throw new BagItException(&quot;Unable to create zip file&quot;);
        }
    }

    /**
     * Create a Tar archive.
     *
     * @param string $filename
     *   The archive filename.
     * @throws \whikloj\BagItTools\BagItException
     *   Problems creating the archive.
     */
    private function makeTar($filename)
    {
        $extension = self::getExtensions($filename);
        $compression = self::extensionTarCompression($extension);
        $tar = new \Archive_Tar($filename, $compression);
        if ($tar === false) {
            throw new BagItException(&quot;Error creating Tar file.&quot;);
        }
        $parent = $this-&gt;getParentDir();
        $files = BagUtils::getAllFiles($this-&gt;bagRoot);
        if (!$tar-&gt;createModify($files, &quot;&quot;, $parent)) {
            throw new BagItException(&quot;Error adding files to {$filename}.&quot;);
        }
    }

    /**
     * Get the parent directory of the current Bag.
     *
     * @return string
     *   The parent directory.
     */
    private function getParentDir()
    {
        $fullPath = $this-&gt;bagRoot;
        return dirname($fullPath);
    }

    /**
     * Uncompress a BagIt archive file.
     *
     * @param string $filepath
     *   The full path to the archive file.
     * @return string
     *   The full path to extracted bag.
     * @throws \whikloj\BagItTools\BagItException
     *   Problems accessing/extracting the archive file.
     */
    private static function uncompressBag($filepath)
    {
        if (file_exists($filepath)) {
            $extension = self::getExtensions($filepath);
            if (in_array($extension, self::ZIP_EXTENSIONS)) {
                $directory = self::unzipBag($filepath);
            } elseif (in_array($extension, self::TAR_EXTENSIONS)) {
                $directory = self::untarBag($filepath, $extension);
            } else {
                throw new BagItException(&quot;Unable to determine archive format.&quot;);
            }
            // $directory contains the directory with the bag, so find it.
            return self::getDirectory($directory);
        }
        throw new BagItException(&quot;File {$filepath} does not exist.&quot;);
    }

    /**
     * Unzip a zip file.
     *
     * @param string $filename
     *   The full path to the zip file.
     * @return string
     *   The path the archive file was extracted to.
     * @throws \whikloj\BagItTools\BagItException
     *   Problems extracting the zip file.
     */
    private static function unzipBag($filename)
    {
        $zip = new \ZipArchive;
        $res = $zip-&gt;open($filename);
        if ($res === false) {
            throw new BagItException(&quot;Unable to unzip {$filename}&quot;);
        }
        $directory = self::extractDir();
        $zip-&gt;extractTo($directory);
        $zip-&gt;close();
        return $directory;
    }

    /**
     * Untar a tar file.
     *
     * @param string $filename
     *   The fullpath to the tar file.
     * @param string $extension
     *   The extension pulled from the filename.
     * @return string
     *   The path the archive file was extracted to.
     * @throws \whikloj\BagItTools\BagItException
     *   Problems extracting the zip file.
     */
    private static function untarBag($filename, $extension)
    {
        $compression = self::extensionTarCompression($extension);
        $directory = self::extractDir();
        $tar = new \Archive_Tar($filename, $compression);
        $res = $tar-&gt;extract($directory);
        if ($res === false) {
            throw new BagItException(&quot;Usable to untar {$filename}&quot;);
        }
        return $directory;
    }

    /**
     * Determine the correct compression (if any) from the extension.
     *
     * @param string $extension
     *   The extension.
     * @return string|null
     *   The compression string or null for no compression.
     */
    private static function extensionTarCompression($extension)
    {
        return (substr($extension, -3) == 'bz2' ? 'bz2' : (substr($extension, -2) == 'gz' ? 'gz' :
            null));
    }

    /**
     * Generate a temporary directory name.
     *
     * @return string
     *   The path to a new temporary directory.
     */
    private static function extractDir()
    {
        $temp = tempnam('', '');
        unlink($temp);
        mkdir($temp);
        return $temp;
    }

    /**
     * Test a filepath to see if we think it is compressed.
     *
     * @param string $filepath
     *   The full path
     * @return bool
     *   True if compressed file (we support).
     */
    private static function isCompressed($filepath)
    {
        return (in_array(self::getExtensions($filepath), array_merge(
            self::ZIP_EXTENSIONS,
            self::TAR_EXTENSIONS
        )));
    }

    /**
     * Get the file extension from a full path.
     *
     * @param string $filepath
     *   The full file path.
     * @return string
     *   The extension or an empty string.
     */
    private static function getExtensions($filepath)
    {
        $filename = strtolower(basename($filepath));
        if (strpos($filename, '.') !== false) {
            return substr($filename, strpos($filename, '.') + 1);
        }
        return '';
    }

    /**
     * Locate the extracted bag directory from inside our temporary directory.
     *
     * @param string $filepath
     *   The temporary directory.
     * @return string
     *   The bag directory.
     * @throws \whikloj\BagItTools\BagItException
     *   Find more or less than one directory (not including . and ..)
     */
    private static function getDirectory($filepath)
    {
        $files = scandir($filepath);
        $dirs = [];
        if (count($files) &gt; 0) {
            foreach ($files as $file) {
                if (BagUtils::isDotDir($file)) {
                    continue;
                }
                $fullpath = $filepath . DIRECTORY_SEPARATOR . $file;
                if (is_dir($fullpath)) {
                    $dirs[] = $fullpath;
                }
            }
        }
        if (count($dirs) !== 1) {
            throw new BagItException(&quot;Found multiple root level directories inside archive file.&quot;);
        }
        return reset($dirs);
    }

    /**
     * Utility to remove files using a pattern.
     *
     * @param string $filePattern
     *   The file pattern.
     * @throws \whikloj\BagItTools\BagItException
     *   Problems deleting files.
     */
    private function clearFilesOfPattern($filePattern)
    {
        $files = BagUtils::findAllByPattern($filePattern);
        if (count($files) &gt; 0) {
            foreach ($files as $file) {
                if (file_exists($file)) {
                    unlink($file);
                }
            }
        }
    }

    /**
     * Utility function to add bag error.
     * @param string $filename
     *   The file the error was detected in.
     * @param string $message
     *   The message.
     */
    private function addBagError($filename, $message)
    {
        $this-&gt;bagErrors[] = [
            'file' =&gt; $filename,
            'message' =&gt; $message
        ];
    }

    /**
     * Utility function to add bag error.
     * @param string $filename
     *   The file the error was detected in.
     * @param string $message
     *   The message.
     */
    private function addBagWarning($filename, $message)
    {
        $this-&gt;bagErrors[] = [
            'file' =&gt; $filename,
            'message' =&gt; $message
        ];
    }

    /**
     * Convert paths from using the OS directory separator to using /.
     *
     * @param string $path
     *   The external path.
     * @return string
     *   The modified path.
     */
    private function internalPath($path)
    {
        return str_replace(DIRECTORY_SEPARATOR, &quot;/&quot;, $path);
    }

    /**
     * Normalize a PHP hash algorithm to a BagIt specification name. Used to alter the incoming $item.
     *
     * @param string $item
     *   The hash algorithm name.
     */
    private static function normalizeHashAlgorithmName(&amp;$item)
    {
        $item = array_flip(self::HASH_ALGORITHMS)[$item];
    }

    /**
     * Check if the algorithm PHP has is allowed by the specification.
     *
     * @param string $item
     *   A hash algorithm name.
     *
     * @return bool
     *   True if allowed by the specification.
     */
    private static function filterPhpHashAlgorithms($item)
    {
        return in_array($item, array_values(self::HASH_ALGORITHMS));
    }

    /**
     * Return the BagIt sanitized algorithm name.
     * @param string $algorithm
     *   A algorithm name
     * @return string|null
     *   The sanitized version of algorithm or null if invalid.
     */
    private function getHashName($algorithm)
    {
        $algorithm = self::trimLower($algorithm);
        $algorithm = preg_replace(&quot;/[^a-z0-9]/&quot;, &quot;&quot;, $algorithm);
        if (in_array($algorithm, array_keys(self::HASH_ALGORITHMS))) {
            return $algorithm;
        }
        return &quot;&quot;;
    }

    /**
     * Do we have a payload manifest with this internal hash name. Internal use only to avoid getHashName()
     *
     * @param string $internal_name
     *   Internal name from getHashName.
     * @return bool
     *   Already have this algorithm.
     */
    private function hasHash($internal_name)
    {
        return (in_array($internal_name, array_keys($this-&gt;payloadManifests)));
    }

    /**
     * Is the internal named hash supported by our PHP. Internal use only to avoid getHashName()
     *
     * @param string $internal_name
     *   Output of getHashName
     * @return bool
     *   Do we support the algorithm
     */
    private function hashIsSupported($internal_name)
    {
        return ($internal_name != null &amp;&amp; in_array($internal_name, $this-&gt;validHashAlgorithms));
    }

    /**
     * Case-insensitive version of array_key_exists
     *
     * @param string $search The key to look for.
     * @param string|int $key The associative or numeric key to look in.
     * @param array $map The associative array to search.
     * @return boolean True if the key exists regardless of case.
     */
    private static function arrayKeyExistsNoCase($search, $key, array $map)
    {
        $keys = array_column($map, $key);
        array_walk($keys, function (&amp;$item) {
            $item = strtolower($item);
        });
        return in_array(strtolower($search), $keys);
    }

    /**
     * Check that the key is not non-repeatable and already in the bagInfo.
     *
     * @param string $key The key being added.
     *
     * @return boolean
     *   True if the key is non-repeatable and already in the
     */
    private function mustNotRepeatBagInfoExists($key)
    {
        return (in_array(strtolower($key), self::BAG_INFO_MUST_NOT_REPEAT) &amp;&amp;
            self::arrayKeyExistsNoCase($key, 'tag', $this-&gt;bagInfoData));
    }

    /**
     * Check that the key is not non-repeatable and already in the bagInfo.
     *
     * @param string $key The key being added.
     *
     * @return boolean
     *   True if the key is non-repeatable and already in the
     */
    private function shouldNotRepeatBagInfoExists($key)
    {
        return (in_array(strtolower($key), self::BAG_INFO_SHOULD_NOT_REPEAT) &amp;&amp;
            self::arrayKeyExistsNoCase($key, 'tag', $this-&gt;bagInfoData));
    }

    /**
     * Parse manifest/tagmanifest file names to determine hash algorithm.
     *
     * @param string $filepath the filename.
     *
     * @return string|null the hash or null.
     */
    private static function determineHashFromFilename($filepath)
    {
        $filename = basename($filepath);
        if (preg_match('~\-([a-z0-9]+)\.txt$~', $filename, $matches)) {
            return $matches[1];
        }
        return null;
    }


    /**
     * Is the requested destination filename reserved on Windows?
     *
     * @param string $filepath
     *   The relative filepath.
     * @return boolean
     *   True if a reserved filename.
     */
    private function reservedFilename($filepath)
    {
        $filename = substr($filepath, strrpos($filepath, '/') + 1);
        return (in_array(strtoupper($filename), self::WINDOWS_RESERVED_NAMES));
    }

    /**
     * Compare the provided version against the current one.
     *
     *
     * @param string $version
     *   The version to compare against.
     * @return int
     *   returns -1 $version &lt; current, 0  $version == current, and 1 $version &gt; current.
     */
    private function compareVersion($version)
    {
        return version_compare($version, $this-&gt;getVersionString());
    }

    /**
     * Utility to merge manifest and fetch errors into the bag errors.
     *
     * @param array $newErrors
     *   The new errors to be added.
     */
    private function mergeErrors(array $newErrors)
    {
        $this-&gt;bagErrors = array_merge($this-&gt;bagErrors, $newErrors);
    }

    /**
     * Utility to merge manifest and fetch warnings into the bag warnings.
     *
     * @param array $newWarnings
     *   The new warnings to be added.
     */
    private function mergeWarnings(array $newWarnings)
    {
        $this-&gt;bagWarnings = array_merge($this-&gt;bagWarnings, $newWarnings);
    }
}
</pre>
        <script type="text/javascript">
             SyntaxHighlighter.all();
             jQuery('.gutter div').each(function(key, data){
                jQuery(data).prepend('<a name="L'+jQuery(data).text()+'"/>');
             });
        </script>
    </body>
</html>